[{"categories":null,"content":"me 僕です。 FIXME: いつか書く\n","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":["tech","programming"],"content":"ClojureコードをコンパイルするとJVMバイトコードが生成される。一般的には、使用するClojureのパージョンさえ固定すれば、 どのような環境でコンパイルしてもコンパイル結果として得られるバイトコードは基本的に同じはずだ。\nしかし、「どのバージョンのJava上でコンパイルしたバイトコードか」が問題になる特殊なケースがあるらしい(実際に遭遇した)ので、記録のためにメモしておく。\nたとえば、次のようなコードがあったとする：\n(import 'java.nio.ByteBuffer) (defn set-pos! [^ByteBuffer b ^long pos] (.position b pos)) これをJava 8上でコンパイルすると、コンパイル結果のバイトコードは以下のようになる：\n 0: aload_0 1: checkcast #15 // class java/nio/Buffer 4: lload_1 5: invokestatic #21 // Method clojure/lang/RT.intCast:(J)I 8: invokevirtual #25 // Method java/nio/Buffer.position:(I)Ljava/nio/Buffer; 11: areturn 一方で、同じコードをJava 9以上でコンパイルすると次のようなバイトコードが出力される：\n 0: aload_0 1: checkcast #15 // class java/nio/ByteBuffer 4: lload_1 5: invokestatic #21 // Method clojure/lang/RT.intCast:(J)I 8: invokevirtual #25 // Method java/nio/ByteBuffer.position:(I)Ljava/nio/ByteBuffer; 11: areturn バイトコードのインストラクションだけ見ていると気づきにくいが、下から2行目 8: invokevirtual #25 から始まる行の呼び出している メソッドの型が違っているのが分かるだろうか。\nJava 8以前では ByteBuffer に対して position(int) メソッドを呼び出すと、Buffer#position(int) が呼ばれ、戻り値の型は Bufferになる。Java 9以降では、 Buffer#positon(int) は残されつつも ByteBuffer に独自のオーバーライド ByteBuffer#position(int) が追加され、その戻り値の型は ByteBuffer だ。 ByteBuffer 自体は Buffer クラスを 継承しているので型の面で特に何かが問題になるということはない。\n問題なのは、バイトコード上に解決されるメソッドだ。 ByteBuffer#position(int) はJava 9で追加されたメソッドなので、 Java 8以前の環境に持っていくと当然そんなメソッドはないとエラーで怒られる：\n;; Clojure 1.9.0 ;; Java HotSpot(TM) 64-Bit Server VM 1.8.0_181-b13 user=\u003e (set-pos! (ByteBuffer/allocate 32) 0) NoSuchMethodError java.nio.ByteBuffer.position(I)Ljava/nio/ByteBuffer; bytebuffer-repro.core/set-pos! (core.clj:5) user=\u003e つまり、 ByteBuffer#position を使っているコードをJava 9以降の環境でコンパイルすると、生成されたバイトコードはJava 8以前の環境では動かなくなる。 同じ問題は ByteBuffer#position の他に ByteBuffer#flip や ByteBuffer#limit、 ByteBuffer#clear にもあるようだ。\n調べてみると、AkkaやMongoDBのJavaドライバーなどのOSSもこの問題に遭遇している。\n https://github.com/akka/akka/issues/23755 https://jira.mongodb.org/browse/JAVA-2559  この問題の解決自体は難しくない。Clojureでは、型ヒントをつけて position メソッドのレシーバが Buffer だと明示してやることで、 メソッドを Buffer#position に解決させることができる：\n(import '[java.nio Buffer ByteBuffer]) (defn set-pos! [^ByteBuffer b ^long pos] (.position ^Buffer b pos)) この例だと、元の b の型ヒントを Buffer に変更してやるのでも問題ない。\nもしくは、レシーバの型ヒントを完全に落としてしまって、実行時にリフレクションで解決してもらう手もあるが、わざわざ型ヒントをつけていたのを 落とすのが現実的な解決策になるケースはあまり多くないと思う：\n(defn set-pos! [b ^long pos] (.position b pos)) なお、この話はあくまでAOTコンパイルをする場合の問題ということに注意。AOTコンパイルしないのであれば、コンパイル環境と実行環境が 食い違うということもないのでそもそも上のような問題は発生しない。AOTコンパイルはしないで済むならしない方が吉。\n","description":"","tags":["TIL","Clojure"],"title":"ByteBufferの使用がバイナリ互換性を破壊するケース","uri":"/post/2018/12/12/bytebuffer-breaks-binary-compatibility/"},{"categories":["tech","programming"],"content":"ClojureのMLからのネタ。\nClojureでは名前空間にエイリアスがつけられて、シンボルやキーワードでそのエイリアスを使った場合に自動的に解決してくれる機能がある：\n(require '[clojure.string :as str]) `str/sym ;=\u003e clojure.string/sym ::str/kw ;=\u003e clojure.string/kw ただし、キーワードのエイリアス解決については、require や alias であらかじめ定義されたエイリアスでない場合にはエラーになる。 このエラーは、そういった解決できないエイリアスのついたキーワードが comment マクロやS式コメント(#_) でコメントアウトされていても回避できないことに注意：\n=\u003e ::unknown/kw RuntimeException Invalid token: ::unknown/kw clojure.lang.Util.runtimeException (Util.java:221) =\u003e (comment ::unknown/kw) RuntimeException Invalid token: ::foo/kw clojure.lang.Util.runtimeException (Util.java:221) RuntimeException Unmatched delimiter: ) clojure.lang.Util.runtimeException (Util.java:221) =\u003e #_ ::unknown/kw RuntimeException Invalid token: ::unknown/kw clojure.lang.Util.runtimeException (Util.java:221) =\u003e それで、MLではこのエラーに対して、1.9で導入されたリーダリゾルバのプラグインの仕組みを使った回避策が述べられている。 MLの回答そのままだとエイリアスの解決をまったくしないのでそのまま実用はできないけど、エイリアス解決を組み込んで使えるように書き換えるとだいたいこんな感じになる：\n(def resolver (reify clojure.lang.LispReader$Resolver (currentNS [_] (.-name *ns*)) (resolveClass [_ sym] sym) (resolveAlias [_ sym] (or (some-\u003e (get (ns-aliases *ns*) sym) ns-name) (binding [*out* *err*] (println (str \"WARNING: unknown alias \\\"\" sym \"\\\" found in \" (ns-name *ns*) \" ns\")) sym))) (resolveVar [_ sym] sym))) (alter-var-root #'*reader-resolver* (constantly resolver)) リーダのエイリアス解決時にリゾルバの resolveAlias が呼ばれるので、とりあえず普通にエイリアスの解決を試みてみて、 ダメならそのエイリアスを(警告を表示したうえで)そのまま返すようにしてやる。\nこれを user.clj などどこか適当なところに書いておいてやると、以下のように見知らぬエイリアスに遭遇してもエラーが出なくなる：\n=\u003e ::unknown/kw WARNING: unknown alias \"unknown\" found in user ns :unknown/kw =\u003e (comment ::unknown/kw) WARNING: unknown alias \"unknown\" found in user ns nil =\u003e #_ ::unknown/kw =\u003e 今回はエラーの解決にのみ注目した使い方をしたけど、たとえば解決できないエイリアスはプロジェクト名をプレフィックスとしてつける といったカスタマイズをすればSpecを使うときに長々と名前空間名をつけたキーワードを書かなくてよくなる、みたいな応用もできるように思う。 ただし、リーダリゾルバはグローバルに影響を与えるので、ライブラリでは使うべきではないし、アプリケーションでも慎重に(そして自己責任で)使うべきでしょう。\n","description":"","tags":["TIL","Clojure"],"title":"解決できないエイリアスをリードしたときにエラーにならないようにする","uri":"/post/2018/08/24/customizing-reader-alias-resolution/"},{"categories":["tech","programming"],"content":"CIでテストを回す場合、テストに失敗したときにCI自体も失敗してくれると嬉しい。\nClojureだと、lein testでテストする場合でもtest-runnerでテストする場合でも、 テストが失敗するとexit(1)してくれるのでテストの失敗をCIも認識してくれる。\n自分で簡単なテストランナーを書く場合でも以下のようにすれば実現できる：\n(require '[clojure.test :as t]) (defn -main [] (let [{:keys [fail error]} (t/run-tests \u003cテスト対象の名前空間\u003e ...)] (System/exit (if (zero? (+ fail error)) 0 1)))) 一方、ClojureScriptの場合を考えてみよう。\nテストを実行する環境がブラウザの場合は事情が厄介なので、ここでは Node.js や Nashorn のようなスタンドアローンな処理系上でのテストを考える (ので、ClojureScript全般のテストの話というより、それらの処理系でテストすれば十分なClojureScriptライブラリのテストの話になる)。\nClojureScriptの clojure.test/run-tests はClojureの場合と違ってテスト結果のサマリーを戻り値として返してくれない。 run-testsのドキュメント文字列にも以下のように書いてある：\n Runs all tests in the given namespaces; prints results. Defaults to current namespace if none given. Does not return a meaningful value due to the possiblity of asynchronous execution.\n つまり、非同期に実行されるテストもあるので、戻り値でテスト結果を返すインターフェースだとうまくないと。\nじゃあどうするかというと、ドキュメント文字列の続きに解決策が書いてあって、\n To detect test completion add a :end-run-tests method case to the cljs.test/report multimethod.\n cljs.test/reportを通して :end-run-tests としてテストの終了が通知されてくるらしい (ちなみに、テストの開始や個々のテストケースの開始・終了も同様にして フックすることができる)。 このときに、テスト結果も引数として渡ってくるので、これを使えば求めている挙動を実現することができる：\n(ns example.core-test (:require [cljs.test :as t])) (def js-exit (cond (exists? js/exit) js/exit ;; Nashornで実行される場合 (exists? js/process.exit) js/process.exit ;; Node.jsで実行される場合 :else identity)) (defmethod t/report [::t/default :end-run-tests] [{:keys [fail error]}] (js-exit (if (zero? (+ fail error)) 0 1))) (defn -main [] (t/run-tests \u003cテスト対象の名前空間\u003e ...)) ","description":"","tags":["TIL","ClojureScript"],"title":"ClojureScriptでテストが失敗したときにexit(1)する","uri":"/post/2018/08/12/exit-with-nonzero-when-cljs-test-failed/"},{"categories":["tech","programming"],"content":"小ネタ。\nClojureScriptのコンパイラオプションというのはcljsbuildでproject.cljに書いたり、 自前でビルドスクリプトを作る場合にはbuild APIに渡すアレ：\n(require 'cljs.build.api) (cljs.build.api/build \"src\" ;; ↓コレがコンパイラオプション {:main 'hello-world.core :output-to \"main.js\" :target :nodejs}) ビルドの仕方によって値が変わってほしい(マクロなら展開結果が変わってほしい)というケースはたまにあって、 解決策はいろいろ考えられるがコンパイラオプションの値によって挙動が変えられれば小回りが利いて便利な場合もある。\nClojureScriptマクロから参照できるコンパイラ環境 env/*compiler* はコンパイラオプションも :options キーに保持しているので、そこからコンパイラオプションにアクセスできる。\nたとえば、REPLを下のように構成して、\n(require '[cljs.repl :as repl] '[cljs.repl.node :as node]) (repl/repl* (node/repl-env) {:output-dir \"target/compiled/js/out\" :optimizations :none :cache-analysis true :app/dev? true ;; ←この値をマクロから参照したい :source-map true}) 以下のようなマクロを定義すると、\n(ns example.macros (:require [cljs.env :as env])) (defmacro dev? `'~(get-in @env/*compiler* [:options :app/dev?])) REPL中から以下のようにコンパイラオプションの値を取得することができる：\n=\u003e (require-macros '[example.macros :refer [dev?]]) nil =\u003e (dev?) true =\u003e ちなみに、コンパイラオプションのキー名は標準的なオプションと近すぎるとREPLがtypoの可能性を警告してくる (し、そうでなくても実際に標準オプションとコンフリクトする可能性がある)ので上の例のように適当なネームスペースをつけておいた方がよさそう。\n","description":"","tags":["TIL","ClojureScript"],"title":"ClojureScriptマクロからコンパイラオプションを参照する","uri":"/post/2017/09/08/how-to-reference-compiler-options-from-cljs-macros/"},{"categories":["tech","programming"],"content":"先日のEuroClojure でのAlex Miller氏の基調講演で、tools.deps.alphaやそれを使った インストーラ等の構想が発表された。\nこれは、1.9でClojure自身が spec.alpha や core.specs.alpha などのライブラリに依存するようになり、 これまでのようにJARをひとつダウンロードしてこればClojureを使い始められるという前提が崩れることへの対応策という 面もあるとのこと。\ntools.deps.alphaの副産物というか主産物というか、cljスクリプトが新たに提供されるように なるとのことで、 このcljスクリプトが本格的に使えるようになると、cljコマンドを叩くだけでClojureを起動できるようになる。 スクリプティングやちょっとClojureを始めてみるような用途にはむしろこれまでのClojureの環境以上に便利に使えそうな雰囲気がある。\nそんなわけで、Clojureが1.9リリースに向けて着々と準備が進んでいる一方で、cljスクリプトでは残念ながら ClojureScriptのサポートはしないことが明言されている。\nしかし、Mike Fikes氏(ClojureScript主要開発メンバー、Planck等のself-hosted CLJS処理系の開発者でもある)が今日、 cljコマンドを介したClojureScriptのREPLを簡単に起動する方法を紹介してくれていた：\n FWIW, @deg, if you create a deps.edn with\n{:deps {org.clojure/clojurescript {:type :mvn, :version \"1.9.908\"}}}\nThen clj -m cljs.repl.node starts a ClojureScript REPL.\n from Clojurian Slack #clojure channel\nつまり、ClojureScriptはもともとClojureの一ライブラリであることと、ClojureScript自身はNode上で動くREPLの 実装を含んでいることから、cljコマンドでClojureScriptを依存ライブラリに指定してワンライナーでREPLを起動することができると。\nClojureScriptはcljsbuildにしろfigwheelにしろビルドの設定が煩雑で、使い始めるまでのハードルがだいぶ 高いので、これぐらいのお手軽さでREPLを起動できるようになると入門者にとっても教える側にとっても嬉しいことが 多いなぁと思った次第でした。\n","description":"","tags":["TIL","ClojureScript"],"title":"これからのClojureScriptの最もお手軽な起動方法？","uri":"/post/2017/08/19/easiest-way-to-start-up-cljs-in-the-future/"},{"categories":["tech","programming"],"content":"ClojureScriptのREPLやeval、マクロ等のコンパイラが関わる部分には「環境」がいろいろ出てくる。 compiler envやanalysis env、compiler stateというのもあるし、マクロの\u0026env、 ClojureScriptで怪しげなことをやってるところでは env/*compiler* というのもよく見かける。\nClojureScriptコンパイラの実装を理解するうえで、これらのうち何が同じもので何が違うものなのか、 違うとしたらどう違うのかを一旦整理しておく必要がありそうだったので調べてまとめてみた。\ncompiler env コンパイラ環境。コンパイルに必要な情報がすべて入っているマップ(を保持するアトム)。 コンパイルの各過程(analyze(AST構築)/compile(JSコード生成)/closure(最適化))で生成された 情報を書き出し、後工程で利用する。\n中身としては以下のような値を持つ(他にもいろいろある)：\n   キー名 説明     :cljs.analyzer/namespaces 依存する名前空間の情報や各名前空間の解析結果を保持する。   :cljs.analyzer/constant-table コンスタントテーブル。定数値から定数インデックスへのマップ。   :cljs.analyzer/data-readers タグつきリテラルのタグからリーダ実装のVarを表すシンボルへのマップ。   :cljs.compiler/compiled-cljs コンパイル中間結果のキャッシュ。   :js-dependency-index シンボル間の依存関係？    この中だと:cljs.analyzer/namespacesが一番使いでがあって、Clojureだとns-*系の関数を介して やるような処理はだいたいこの情報を介してできるようになっている。\ncompiler state compiler stateというのも実はcompiler envと同じものを指しているらしい。 呼び分けに何か区別があるのかはよく分かっていないけど、cljs.analyzer.apiやcljs.js等の ユーザ向けのAPIではこの名前が使われていることが多い印象。\nenv/*compiler* cljs.envで定義されている動的変数。現在のコンパイラ環境が束縛されている。 実行時には何も取得できないが、コンパイル時には有効になっているのでマクロからは参照可能。\nanalysis env コンパイラ環境がコンパイルのプロセス全般に渡って必要となる情報をまとめている一方、analysis env(解析環境) の方はトップレベルフォーム1つの解析時に必要となる情報を持っている。 analyzerの文脈でenvというと大抵こちら。\n「現在の名前空間」について、:cljs.analyzer/namespacesが持つデータをコピーして持っているほか、 今解析しているフォームから見えているローカルな束縛の解析結果等も持つ。\n\u0026env マクロの暗黙の引数\u0026envには解析環境が渡ってくる。これはClojureの場合の\u0026envとは 構造が違い、互換性はない(この差異を利用して、マクロがClojureの文脈で呼び出されているのか、 ClojureScriptの文脈で呼び出されているのかを判別するテクニックがあるらしい)。\n","description":"","tags":["TIL","ClojureScript"],"title":"ClojureScriptコンパイラにまつわる「環境」あれこれ","uri":"/post/2017/08/14/various-enviroments-in-clojurescript-compiler/"},{"categories":["tech","programming"],"content":"たとえば、「整数をとる:xというキー」と「文字列をとる:yというキー」をもつマップのスペックは以下のように表現できる：\n(s/def ::x integer?) (s/def ::y string?) (s/keys :req-un [::x ::y]) ;; (s/valid? (s/keys :req-un [::x ::y]) {:x 1}) ;; =\u003e false ;; 両方のキーがないとダメ もし、「:xと:yの少なくともどちらか一方をもつ」という条件ならこう書ける：\n(s/keys :req-un [(::x ::y)] ;; (s/valid? (s/keys :req-un [(or ::x ::y)]) {:x 1}) ;; =\u003e true ;; 片方のキーだけでもOK :reqや:req-unのベクタ内では、orだけでなくandも使えるようになっていて、キーの複雑な存在条件を記述することだできるようになっている。 この機能はあまり知られていないがs/keysのdocstringにもちゃんと書いてある：\nThe :req key vector supports 'and' and 'or' for key groups: (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])  ところで、上の例ではorを使っているので、当然:xも:yも両方とも持つ場合もいいことになる：\n(s/valid? (s/keys :req-un [(or ::x ::y)]) {:x 1 :y \"foo\"}) ;; =\u003e true たまに聞く話として「どちらか一方のキーのみをもつ場合しか受けつけたくないときはどうすればいいんだ？」というのがあるようだ (個人的には、今のところそういうスペックがほしいと思うケースに遭遇したことはない)。\nそのような場合には、以下のようなスペックを書くのが常套的かと思う：\n(s/and (s/keys :req-un [(or ::x ::y)]) (fn [m] (or (and (contains? m :x) (not (contains? m :y))) (and (not (contains? m :y)) (contains? m :y))))) つまり、s/keysだけでは所望の条件を表現できないので、s/andないしs/mergeで追加の条件をつけてやるという話。\nそういうものかと納得してしまえばそれまでの話なんだけど、たまたまs/keysの実装を読んでいたら、 s/keys内で使えるandやorの位置には、実はそのスコープで見えてる任意の関数・マクロが使えるということのようだ。\nこれは単に今の時点でs/keysの構文チェックを厳密にしていないための不具合というか未定義動作なので、この挙動を利用して 何をかしようとするのはまったくもってお薦めしないのだけど、この挙動を使えばさっきの例はs/keysの中でしれっとnotを使ってやることで 以下のようにすっきりと書くことができる：\n(s/keys :req-un [(or (and ::x (not ::y)) (and (not ::x) ::y))]) ;; 両方のキーがあるとダメ ;; (s/valid? (s/keys :req-un [(or (and ::x (not ::y)) (and (not ::x) ::y))]) {:x 1 :y \"foo\"}) ;; =\u003e false ;; 片方のキーのみならOK ;; =\u003e false ;; (s/valid? (s/keys :req-un [(or (and ::x (not ::y)) (and (not ::x) ::y))]) {:x 1}) ;; =\u003e true ;; (s/valid? (s/keys :req-un [(or (and ::x (not ::y)) (and (not ::x) ::y))]) {:y \"foo\"}) ;; =\u003e true ","description":"","tags":["TIL","Clojure"],"title":"「2つのキーのどちらか一方のみを含むマップ」を表現するスペック","uri":"/post/2017/08/03/specing-maps-with-exclusive-keys/"},{"categories":["tech","programming"],"content":"ほとんどの人にとっては誰得情報かと思いますが。。。\nCriteriumといえば、Clojure界隈ではベンチマークツールの決定版的な位置づけのライブラリ。 外れ値の検出等の統計的な処理はもちろん、ベンチマーク結果がGCの影響を受けないようにGCをオフにしたり、JITコンパイルによってコードが 十分に最適化された状態になるまでウォームアップをしてくれたりと、JVM上でベンチマークをとるうえで気をつける必要がある点について かなりしっかりとケアしてくれる。\nで、今回の問題はそんな手厚いケアがアダになったケースといえそう。\n今やっていたのは、「一般的にはevalが必要になるが条件が揃うとevalする必要がある部分を大幅に(もしくは完全に)削減できる」 という問題に対して、その対策になるようなライブラリを作ったらナイーブにevalを呼ぶ場合と比較してどれくらい速くなるのか、というのを ひとまずプロトタイプを作ってベンチマークをとってみるということ。\nまず、ライブラリ側のコードをベンチマークしてみる。小さいサイズの入力について、理想的な条件が揃う場合にはevalなしに直接実行しているのと ほとんど遜色ないくらいの速度が出る。目論見どおり。\n次にevalを使ったコードの場合。ライブラリと同じようベンチマークを始める。\n…待てども待てどもベンチマークが全然終わらない。\nCriteriumはベンチマークするコードを何回も繰り返して実行時間のサンプルをとるので結果が出るまでに多少がかかるのだけど、最初に 1回あたりの実行時間を計測してうえで何回ベンチマークコードを実行するのかを見積もるので、(ベンチマークコード1回の実行が延々かかる ということでもなければ)ベンチマークが終わらないということはないはず。\n何かがおかしい。\nそこで、このベンチマークをとっている間にCriterium内部で何が起こっているのか調べるために with-progress-reporting をつけて 進捗を報告してもらう。\nWarming up for JIT optimisations 5000000000 ... classes loaded before 1 iterations classes loaded before 434 iterations compilation occurred before 434 iterations classes loaded before 867 iterations classes loaded before 1300 iterations classes loaded before 1733 iterations classes loaded before 2166 iterations classes loaded before 2599 iterations classes loaded before 3032 iterations classes loaded before 3465 iterations classes loaded before 3898 iterations classes loaded before 4331 iterations classes loaded before 4764 iterations classes loaded before 5197 iterations classes loaded before 5630 iterations classes loaded before 6063 iterations ... この “classes loaded before … iterations” の行が延々と続く。なぜ？\nCriteriumのコードを読むと、この行は要するにクラスロードが新たに生じるうちはJITコンパイルが安定した状態にないと判断して ウォームアップを続けていることを表しているようだ。\nClojureのコードは通常(AOTコンパイルされていなければ)実行時にコンパイルされ、JVMバイトコードが生成される。 つまり、そのタイミングで新たにクラスが生成され、ロードされる。ただし、同一の関数は一度コンパイルされてしまえば、 その後何度呼び出してもクラスが新たに生成されることはない。Criteriumはベンチマークコードを関数にくるんで実行するので、この点について問題はない。\nしかし、evalを使った場合は別だ。evalを使うと、evalを呼び出した時点でコンパイルが走り、バイトコードが生成され、クラスがロードされる。 evalを呼び出すたびにクラスがロードされるので、Criteriumのウォームアップはいつまでも終わらない。\nこの現象はevalの呼び出し以外では意図的にクラスロードするようなコードでしか発生しないので大半の人は遭遇しないだろうけど、 なかなか思い当たらない意外な落とし穴なので注意したい。\n","description":"","tags":["TIL","Clojure"],"title":"Criteriumはevalのベンチマークには使えない","uri":"/post/2017/07/05/criterium-cannot-be-used-for-benchmarking-eval/"},{"categories":["tech","programming"],"content":"ClojureScriptの不具合らしき挙動に遭遇したのでパッチを作ろうとするも、 普段cljsbuildやらFigwheelなんかのツールを介してしかClojureScriptに触れていないので、素のClojureScriptをどう動かせばいいのか すら分からない状態。\nとりあえず必要最低限、素のClojureScriptでの動作確認とテストをするところまではやったので、備忘録として残しておく。\nブートストラップ 以下のスクリプトを実行するだけ：\n$ ./script/bootstrap 実際には、依存ライブラリなんかをダウンロードしてきてlib/以下に置いている。依存ライブラリ、特にClojureのバージョンが違ったりすると REPLの起動でコケたりするので忘れずにやる。\nlib/以下も含め、一旦綺麗にしたい場合は、あらかじめ以下も実行しておく：\n$ ./script/clean REPL起動 一旦ブートストラップできたら以下でREPLが起動できる：\n$ ./script/repljs このスクリプトはJSランタイムとしてRhinoを使ってREPLを起動する。\nNode.jsやNashornを使ってREPLを起動したい場合には、それぞれ script/noderepljsやscript/nashornrepljsを使う。\nscript/replというスクリプトもあるんだけど、こっちは実際にはClojureのREPLが立ち上がってそこからClojureScriptの REPL環境やらを自前でロードして使う感じなので、サクッとREPLを起動したいだけの用途には向かない。\nテスト実行 ClojureScriptコンパイラ等、Clojureで書かれてたコードをテストする場合には以下を実行する：\n$ lein test ClojureScriptで書かれたコード(コアライブラリやセルフホスティングコンパイラ)等に関するテストは上のコマンドには含まれない。\nコアライブラリのテストをしたい場合には以下を実行する：\n$ ./script/test ただし、このスクリプトはテストで使うJSランタイムが見つからないとテストコードのビルドだけをして終了してしまうので注意が必要。 JSランタイムは環境変数等で指定してやる必要がある。 詳しくはこちらを参照。\n","description":"","tags":["TIL","ClojureScript"],"title":"ClojureScript自身の開発のはじめかた","uri":"/post/2017/06/24/getting-started-with-clojurescript-development/"},{"categories":["tech","programming"],"content":"結論 以下のように、\nhttps://clojars.org/search?q=at%3A%5B1496275200000+TO+1496361600000%5D\u0026format=json\n検索クエリとして at:[\u003c検索開始日\u003e TO \u003c検索終了日\u003e] の形式で検索する日付の期間を指定してやればよい (日付はどちらも1970/1/1 00:00:00 GMTからの経過ミリ秒)。\n経緯 ClojarsのJSON (or XML) Search APIのドキュメント)には、 基本的なライブラリの名前での検索方法は書いてあっても、その他のフィールドによる検索、たとえばライブラリが登録された日付による 検索の仕方は載っていない。\n今とある用件でClojarsで公開されているライブラリのアップデートを検知する仕組みを作ることを検討中なのだけど、これがAPI経由で 取得できないとなると、1時間に1回作り直されるというPOMファイルのリストやJARのリストを クローリングしてdiffを取り、そこからJARをダウンロードするなり、改めて該当するライブラリの情報をAPIでとってくるというようなことを やらないといけないけど、それはわりと面倒。\n幸い、別のドキュメントによれば、Clojarsが 内部で使っているLuceneの検索クエリがそのまま使えるようなのでいろいろ試してみる。\nしかし、そのためにはライブラリの登録日がLucene上でどこにどういう形式で保存されているのか分からないといけない。 Clojarsの公開されているコードを読んでいると、このあたりに ライブラリ登録日がLucene上で at という名前で保存されているのを発見。\nそこで、おもむろにat:[2017-01-01 TO *]みたいなクエリを試してみたがうまくいかず。その周辺にあったその他のフィールド(group-idとか versionとか)での検索は通っているみたいなので、値のレンジの指定方法が間違っていることに気づく。\nそこから、時間まで含めて指定してみたりタイムゾーンも必要かと思ってやっていたけれど埒が明かず。再度改めてコードを見直していると このあたりにatを数値として 比較しているのを発見。なるほど、UNIX時間か！(正確にはUNIX時間ではなく、Javaでより取得しやすいエポックタイムからの経過ミリ秒だった)\nあとは、値のレンジ指定で使えるはずの*が(URLエンコードされたクエリをうまくデコードできていないせいか(未検証))機能していないのもあって、両端ともちゃんと値を 指定してやれば期待した検索結果が得られたという顛末。\nしかし、結局そうやって得られた検索結果も、実はClojarsの検索APIがページネーションをしてくれてないせいで、高々24件までしか 取得できない(ちなみに、この件数はClojarsの検索結果を表示するページのレイアウトの都合ということらしい)。Clojureのライブラリは そこまで高頻度に登録されないので、本来やりたいこと(ライブラリ登録の検知)に対しては1時間おきにでもポーリングしてやれば24件を 超えることはないだろうからそれで十分だけど、まぁ暇があったら検索APIでページネーションできるようプルリクエストもしておきたい。\nそんなお話。\n","description":"","tags":["TIL","Clojure"],"title":"Clojarsの検索APIでライブラリ登録日によるフィルタリング","uri":"/post/2017/06/03/clojars-query-for-search-by-created-date/"},{"categories":["tech","programming"],"content":"updateやupdate-inが便利すぎてついつい使いすぎてしまう。 気づくと「もっとストレートな書き方があるのに…」というパターン(update+assocとかupdate-in+updateとか)を書いていたりするのでちょっと整理してみた。\n前提 get/assoc/updateの性質  (get (assoc m k v) k) = v (assoc m k (get m k)) = m (update m k f x ...) = (assoc m k (f (get m k) x ...))  get-in/assoc-in/update-inの形式的定義 get-in  (get-in m [k]) = (get m k) (get-in m [k ks ...]) = (get (get-in m [ks ...]) k)  assoc-in  (assoc-in m [k] v) = (assoc m k v) (assoc-in m [k ks ...] v) = (assoc m k (assoc-in (get m k) ks v))  update-in  (update-in m [k] f x ...) = (update m k f x ...) (update-in m [k ks ...] f x ...) = (update m k update-in [ks ...] f x ...)  get-in/assoc-in/update-inの書き換え 以上のget/assoc/updateの性質とget-in/assoc-in/update-inの定義から、次が導出できる(はず)。\n単純な書き換え  (get-in (get m k) [ks ...]) = (get-in m [k ks ...]) (get-in (get-in m [ks1 ...]) [ks2 ...]) = (get-in m [ks1 ... ks2 ...]) (assoc-in m [ks ...] (assoc (get-in m [ks ...]) k v)) = (assoc-in m [ks ... k] v)  特に、(empty? (get-in m [ks ...]))の場合、(assoc-in m [ks ...] (assoc {} k v)) = (assoc-in m [ks ... k] v)   (assoc-in m [ks1 ...] (assoc-in (get-in m [ks1 ...]) [ks2 ...] v)) = (assoc-in m [ks1 ... ks2 ...] v)  特に、(empty? (get-in m [ks1 ...]))の場合、(assoc-in m [ks1 ...] (assoc-in {} [ks2 ...] v)) = (assoc-in m [ks1 ... ks2 ...] v)   (update-in m [ks ...] update k f x ...) = (update-in m [ks ... k] f x ...) (update-in m [ks1 ...] update-in [ks2 ...] f x ...) = (update-in [ks1 ... ks2 ...] f x ...)  より複雑な書き換え  (assoc m k1 (update (get m k1) k2 f x ...)) = (update-in m [k1 k2] f ...)  特に、(empty? (get m k1))の場合、(assoc m k1 (update {} k2 f x ...)) = (update-in m [k1 k2] f ...)   (assoc-in m [ks1 ...] (update-in (get-in m [ks1 ...]) [ks2 ...] f x ...)) = (update-in m [ks1 ... ks2 ...] f x ...)  特に、(empty? (get-in m [ks1 ...]))の場合、(assoc-in m [ks1 ...] (update-in {} [ks2 ...] f x ...)) = (update-in m [ks1 ... ks2 ...] f x ...)   (update m k1 assoc k2 v) = (assoc-in m [k1 k2] v) (update-in m [ks1 ...] assoc-in [ks2 ...] v) = (assoc-in m [ks1 ... ks2 ...] v)  証明 読者への課題とする。□\n","description":"","tags":["TIL","Clojure"],"title":"Associativeな値の操作関数の等価な書き換え","uri":"/post/2016/06/21/transformations-between-combinations-of-associative-fns/"},{"categories":["tech","programming"],"content":"ClojureScriptのOmラッパーのひとつであるReagentでは、DOMをClojureScriptのデータ(ベクタやマップ)として書く。\nこのDOMを表すデータに含まれる文字列はデフォルトでHTMLエスケープされる。これを回避するにはReactのdangerouslySetInnerHTMLの機能を使う。\n[:div {:dangerouslySetInnerHTML {:__html \"\u003cb\u003eThis is an unescaped HTML!!\u003c/b\u003e\"}}] 参考  https://github.com/reagent-project/reagent/issues/14 https://facebook.github.io/react/tips/dangerously-set-inner-html.html ","description":"","tags":["TIL","ClojureScript"],"title":"ReagentでエスケープされていないHTMLを埋め込む","uri":"/post/2016/05/18/embed-unescaped-html-into-reagent-dom/"},{"categories":["tech","programming"],"content":"タイトルの通り。\nnameはnamespaceと対になる関数で、c.l.Namedなオブジェクトの名前空間修飾を除いた名前部分の文字列を返す。\n(name 'foo/bar) ;=\u003e \"bar\" そういう理解だったのでてっきりNamedなオブジェクト、つまりシンボルとキーワードに対してしか適用できないと思っていた。 なので、これまで「シンボル、キーワードもしくは文字列を受け取って文字列に型変換する」という場合には、以下のように書いていた：\n(if (string? x) x (name x)) nameが文字列も受け取れることを利用すると、実は簡潔にこう書ける：\n(name x) ちなみに、「シンボル、キーワードもしくは文字列を受け取ってキーワードに型変換する」場合には、keywordがシンボル/キーワード/文字列を受け取れることを利用して次のように書ける：\n(keyword x) Clojureでは、enum的な値が欲しくなった場合にシンボル/キーワード/文字列を使うことが多い(シンボルを使うケースは比較的少ないが)。また、往々にしてこれらの値はinterchangeableに使えることが期待されるので、これらの値の簡潔な相互変換の方法は重宝する。\n","description":"","tags":["TIL","Clojure"],"title":"name関数は文字列を受け取る","uri":"/post/2016/05/17/name-function-can-accept-strings/"}]